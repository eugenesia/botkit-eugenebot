0 info it worked if it ends with ok
1 verbose cli [ '/usr/local/bin/node', '/usr/local/bin/npm', 'publish' ]
2 info using npm@1.3.11
3 info using node@v0.10.21
4 verbose publish [ '.' ]
5 verbose cache add [ '.', null ]
6 verbose cache add name=undefined spec="." args=[".",null]
7 verbose parsed url { protocol: null,
7 verbose parsed url   slashes: null,
7 verbose parsed url   auth: null,
7 verbose parsed url   host: null,
7 verbose parsed url   port: null,
7 verbose parsed url   hostname: null,
7 verbose parsed url   hash: null,
7 verbose parsed url   search: null,
7 verbose parsed url   query: null,
7 verbose parsed url   pathname: '.',
7 verbose parsed url   path: '.',
7 verbose parsed url   href: '.' }
8 silly lockFile 3a52ce78- .
9 verbose lock . /Users/ben/.npm/3a52ce78-.lock
10 verbose tar pack [ '/var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz',
10 verbose tar pack   '.' ]
11 verbose tarball /var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
12 verbose folder .
13 silly lockFile 1f1177db-tar tar://.
14 verbose lock tar://. /Users/ben/.npm/1f1177db-tar.lock
15 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
16 verbose lock tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz /Users/ben/.npm/e6ac6569-751-0-006953514646738768-tmp-tgz.lock
17 silly lockFile 1f1177db-tar tar://.
18 silly lockFile 1f1177db-tar tar://.
19 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
20 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
21 verbose tar unpack /var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
22 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
23 verbose lock tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package /Users/ben/.npm/31d1f139-751-0-006953514646738768-package.lock
24 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
25 verbose lock tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz /Users/ben/.npm/e6ac6569-751-0-006953514646738768-tmp-tgz.lock
26 silly gunzTarPerm modes [ '755', '644' ]
27 silly gunzTarPerm extractEntry package.json
28 silly gunzTarPerm extractEntry .npmignore
29 silly gunzTarPerm extractEntry bot.js
30 silly gunzTarPerm extractEntry examples/convo_bot.js
31 silly gunzTarPerm extractEntry examples/demo_bot.js
32 silly gunzTarPerm extractEntry examples/incoming_webhooks.js
33 silly gunzTarPerm extractEntry examples/slack_app.js
34 silly gunzTarPerm extractEntry examples/slackbutton_bot.js
35 silly gunzTarPerm extractEntry examples/slackbutton_incomingwebhooks.js
36 silly gunzTarPerm extractEntry examples/slackbutton_slashcommand.js
37 silly gunzTarPerm extractEntry examples/team_outgoingwebhook.js
38 silly gunzTarPerm extractEntry examples/team_slashcommand.js
39 silly gunzTarPerm extractEntry LICENSE.md
40 silly gunzTarPerm extractEntry .editorconfig
41 silly gunzTarPerm extractEntry .jscsrc
42 silly gunzTarPerm extractEntry lib/Botkit.js
43 silly gunzTarPerm extractEntry lib/CoreBot.js
44 silly gunzTarPerm extractEntry lib/SlackBot.js
45 silly gunzTarPerm extractEntry lib/Slack_web_api.js
46 silly gunzTarPerm extractEntry lib/Slackbot_worker.js
47 silly gunzTarPerm extractEntry lib/console_logger.js
48 silly gunzTarPerm extractEntry lib/storage/firebase_storage.js
49 silly gunzTarPerm extractEntry lib/storage/redis_storage.js
50 silly gunzTarPerm extractEntry lib/storage/simple_storage.js
51 silly gunzTarPerm extractEntry lib/storage/storage_test.js
52 silly gunzTarPerm extractEntry readme.md
53 silly gunzTarPerm extractEntry CONTRIBUTING.md
54 silly gunzTarPerm extractEntry tests/Slack_web_api.js
55 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
56 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
57 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
58 silly lockFile e6ac6569-751-0-006953514646738768-tmp-tgz tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/tmp.tgz
59 verbose tar pack [ '/Users/ben/.npm/botkit/0.0.7/package.tgz',
59 verbose tar pack   '/var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package' ]
60 verbose tarball /Users/ben/.npm/botkit/0.0.7/package.tgz
61 verbose folder /var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
62 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
63 verbose lock tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package /Users/ben/.npm/31d1f139-751-0-006953514646738768-package.lock
64 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
65 verbose lock tar:///Users/ben/.npm/botkit/0.0.7/package.tgz /Users/ben/.npm/8827c054-ben-npm-botkit-0-0-7-package-tgz.lock
66 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
67 silly lockFile 31d1f139-751-0-006953514646738768-package tar:///var/folders/yz/b97tdj8s0qx63_kztdwdwmvr0000gn/T/npm-70187-PyPO-Jtd/1455575975751-0.006953514646738768/package
68 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
69 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
70 silly lockFile 9e9bd62a-ers-ben-npm-botkit-0-0-7-package /Users/ben/.npm/botkit/0.0.7/package
71 verbose lock /Users/ben/.npm/botkit/0.0.7/package /Users/ben/.npm/9e9bd62a-ers-ben-npm-botkit-0-0-7-package.lock
72 silly lockFile 9e9bd62a-ers-ben-npm-botkit-0-0-7-package /Users/ben/.npm/botkit/0.0.7/package
73 silly lockFile 9e9bd62a-ers-ben-npm-botkit-0-0-7-package /Users/ben/.npm/botkit/0.0.7/package
74 verbose tar unpack /Users/ben/.npm/botkit/0.0.7/package.tgz
75 silly lockFile be2a00c9-ers-ben-npm-botkit-0-0-7-package tar:///Users/ben/.npm/botkit/0.0.7/package
76 verbose lock tar:///Users/ben/.npm/botkit/0.0.7/package /Users/ben/.npm/be2a00c9-ers-ben-npm-botkit-0-0-7-package.lock
77 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
78 verbose lock tar:///Users/ben/.npm/botkit/0.0.7/package.tgz /Users/ben/.npm/8827c054-ben-npm-botkit-0-0-7-package-tgz.lock
79 silly gunzTarPerm modes [ '755', '644' ]
80 silly gunzTarPerm extractEntry package.json
81 silly gunzTarPerm extractEntry .npmignore
82 silly gunzTarPerm extractEntry bot.js
83 silly gunzTarPerm extractEntry CONTRIBUTING.md
84 silly gunzTarPerm extractEntry LICENSE.md
85 silly gunzTarPerm extractEntry .jscsrc
86 silly gunzTarPerm extractEntry examples/convo_bot.js
87 silly gunzTarPerm extractEntry examples/demo_bot.js
88 silly gunzTarPerm extractEntry examples/incoming_webhooks.js
89 silly gunzTarPerm extractEntry examples/slack_app.js
90 silly gunzTarPerm extractEntry examples/slackbutton_bot.js
91 silly gunzTarPerm extractEntry examples/slackbutton_incomingwebhooks.js
92 silly gunzTarPerm extractEntry examples/slackbutton_slashcommand.js
93 silly gunzTarPerm extractEntry examples/team_outgoingwebhook.js
94 silly gunzTarPerm extractEntry examples/team_slashcommand.js
95 silly gunzTarPerm extractEntry lib/Botkit.js
96 silly gunzTarPerm extractEntry lib/CoreBot.js
97 silly gunzTarPerm extractEntry lib/SlackBot.js
98 silly gunzTarPerm extractEntry lib/Slack_web_api.js
99 silly gunzTarPerm extractEntry lib/Slackbot_worker.js
100 silly gunzTarPerm extractEntry lib/console_logger.js
101 silly gunzTarPerm extractEntry lib/storage/firebase_storage.js
102 silly gunzTarPerm extractEntry lib/storage/redis_storage.js
103 silly gunzTarPerm extractEntry lib/storage/simple_storage.js
104 silly gunzTarPerm extractEntry lib/storage/storage_test.js
105 silly gunzTarPerm extractEntry .editorconfig
106 silly gunzTarPerm extractEntry readme.md
107 silly gunzTarPerm extractEntry tests/Slack_web_api.js
108 silly lockFile be2a00c9-ers-ben-npm-botkit-0-0-7-package tar:///Users/ben/.npm/botkit/0.0.7/package
109 silly lockFile be2a00c9-ers-ben-npm-botkit-0-0-7-package tar:///Users/ben/.npm/botkit/0.0.7/package
110 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
111 silly lockFile 8827c054-ben-npm-botkit-0-0-7-package-tgz tar:///Users/ben/.npm/botkit/0.0.7/package.tgz
112 verbose chmod /Users/ben/.npm/botkit/0.0.7/package.tgz 644
113 verbose chown /Users/ben/.npm/botkit/0.0.7/package.tgz [ 501, 20 ]
114 silly lockFile 3a52ce78- .
115 silly lockFile 3a52ce78- .
116 silly publish { name: 'botkit',
116 silly publish   version: '0.0.7',
116 silly publish   description: 'Building blocks for Building Bots',
116 silly publish   main: 'lib/Botkit.js',
116 silly publish   dependencies:
116 silly publish    { 'body-parser': '^1.14.2',
116 silly publish      express: '^4.13.3',
116 silly publish      jfs: '^0.2.6',
116 silly publish      mustache: '^2.2.1',
116 silly publish      request: '^2.67.0',
116 silly publish      ws: '^1.0.0' },
116 silly publish   devDependencies:
116 silly publish    { jscs: '^2.7.0',
116 silly publish      'node-env-file': '^0.1.8',
116 silly publish      should: '^8.0.2',
116 silly publish      'tap-spec': '^4.1.1',
116 silly publish      tape: '^4.4.0',
116 silly publish      winston: '^2.1.1' },
116 silly publish   scripts: { pretest: 'jscs ./lib/', test: 'mocha tests/*.js' },
116 silly publish   repository: { type: 'git', url: 'https://github.com/howdyai/botkit.git' },
116 silly publish   bugs: { url: 'https://github.com/howdyai/botkit/issues' },
116 silly publish   homepage: 'http://howdy.ai/botkit',
116 silly publish   keywords: [ 'bots', 'chatbots', 'slack' ],
116 silly publish   author: { name: 'ben@xoxco.com' },
116 silly publish   license: 'MIT',
116 silly publish   readme: '# [Botkit](http://howdy.ai/botkit) - Building Blocks for Building Bots\n\nBotkit designed to ease the process of designing and running useful, creative or just plain weird bots (and other types of applications) that live inside [Slack](http://slack.com)!\n\nIt provides a semantic interface to sending and receiving messages\nso that developers can focus on creating novel applications and experiences\ninstead of dealing with API endpoints.\n\nBotkit features a comprehensive set of tools\nto deal with [Slack\'s integration platform](http://api.slack.com), and allows\ndevelopers to build both custom integrations for their\nteam, as well as public "Slack Button" applications that can be\nrun from a central location, and be used by many teams at the same time.\n\n## Installation\n\nBotkit is available via NPM.\n\n```bash\nnpm install --save botkit\n```\n\nYou can also check out Botkit directly from Git.\nIf you want to use the example code and included bots, it may be preferable to use Github over NPM.\n\n```bash\ngit clone git@github.com:howdyai/botkit.git\n```\n\nAfter cloning the Git repository, you have to install the node dependencies. Navigate to the root of your cloned repository and use npm to install all necessary dependencies.\n```bash\nnpm install\n```\n\nUse the `--production` flag to skip the installation of devDependencies from Botkit. Useful if you just wish to run the example bot.\n```bash\nnpm install --production\n```\n\n\n## Getting Started\n\n1) Install Botkit. See [Installation](#installation) instructions.\n\n2) First make a bot integration inside of your Slack channel. Go here:\n\nhttps://my.slack.com/services/new/bot\n\nEnter a name for your bot.\nMake it something fun and friendly, but avoid a single task specific name.\nBots can do lots! Let\'s not pigeonhole them.\n\n3) When you click "Add Bot Integration", you are taken to a page where you can add additional details about your bot, like an avatar, as well as customize its name & description.\n\nCopy the API token that Slack gives you. You\'ll need it.\n\n4) Run the example bot app, using the token you just copied:\n​\n```\ntoken=REPLACE_THIS_WITH_YOUR_TOKEN node bot.js\n```\n​\n5) Your bot should be online! Within Slack, send it a quick direct message to say hello. It should say hello back!\n\nTry:\n  * who are you?\n  * call me Bob\n  * shutdown\n​\n\n### Things to note\n​\nMuch like a vampire, a bot has to be invited into a channel. DO NOT WORRY bots are not vampires.\n\nType: `/invite @<my bot>` to invite your bot into another channel.\n\n\n## Core Concepts\n\nBots built with Botkit have a few key capabilities, which can be used\nto create clever, conversational applications. These capabilities\nmap to the way real human people talk to each other.\n\nBots can [hear things](#receiving-messages). Bots can [say things and reply](#sending-messages) to what they hear.\n\nWith these two building blocks, almost any type of conversation can be created.\n\nTo organize the things a bot says and does into useful units, Botkit bots have a subsystem available for managing [multi-message conversations](#multi-message-replies-to-incoming-messages). Conversations add features like the ability to ask a question, queue several messages at once, and track when an interaction has ended.  Handy!\n\nAfter a bot has been told what to listen for and how to respond,\nit is ready to be connected to a stream of incoming messages. Currently, Botkit can handle [3 different types of incoming messages from Slack](#connecting-your-bot-to-slack).\n\n\n## Basic Usage\n\nHere\'s an example of using Botkit with Slack\'s [real time API](https://api.slack.com/rtm), which is the coolest one because your bot will look and act like a real user inside Slack.\n\nThis sample bot listens for the word "hello" to be said to it -- either as a direct mention ("@bot hello") or an indirect mention ("hello @bot") or a direct message (a private message inside Slack between the user and the bot).\n\nThe Botkit constructor returns a `controller` object. By attaching event handlers\nto the controller object, developers can specify what their bot should look for and respond to,\nincluding keywords, patterns and various [messaging and status events](#responding-to-events).\nThese event handlers can be thought of metaphorically as skills or features the robot brain has -- each event handler defines a new "When a human say THIS the bot does THAT."\n\nThe `controller` object is then used to `spawn()` bot instances that represent\na specific bot identity and connection to Slack. Once spawned and connected to\nthe API, the bot user will appear online in Slack, and can then be used to\nsend messages and conduct conversations with users. They are called into action by the `controller` when firing event handlers.\n\n\n```javascript\nvar Botkit = require(\'botkit\');\n\nvar controller = Botkit.slackbot({\n  debug: false\n  //include "log: false" to disable logging\n  //or a "logLevel" integer from 0 to 7 to adjust logging verbosity\n});\n\n// connect the bot to a stream of messages\ncontroller.spawn({\n  token: <my_slack_bot_token>,\n}).startRTM()\n\n// give the bot something to listen for.\ncontroller.hears(\'hello\',[\'direct_message\',\'direct_mention\',\'mention\'],function(bot,message) {\n\n  bot.reply(message,\'Hello yourself.\');\n\n});\n\n```\n\n## Included Examples\n\nThese examples are included in the Botkit [Github repo](https://github.com/howdyai/botkit).\n\n[bot.js](https://github.com/howdyai/botkit/blob/master/bot.js) An example bot that can be connected to your team. Useful as a basis for creating your first bot!\n\n[examples/demo_bot.js](https://github.com/howdyai/botkit/blob/master/examples/demo_bot.js) another example bot that uses different ways to send and receive messages.\n\n[examples/slackbutton_bot.js](https://github.com/howdyai/botkit/blob/master/examples/slackbutton_bot.js) an example of using the Slack Button to offer a bot integration.\n\n[examples/slackbutton_incomingwebhooks.js](https://github.com/howdyai/botkit/blob/master/examples/slackbutton_incomingwebhooks.js) an example of using the Slack Button to offer an incoming webhook integration. This example also includes a simple form which allows you to broadcast a message to any team who adds the integration.\n\n# Developing with Botkit\n\nTable of Contents\n\n* [Connecting Your Bot To Slack](#connecting-your-bot-to-slack)\n* [Receiving Messages](#receiving-messages)\n* [Sending Messages](#sending-messages)\n* [Working with Slack Integrations](#working-with-slack-integrations)\n* [Advanced Topics](#advanced-topics)\n\n## Connecting Your Bot to Slack\n\nBot users connect to Slack using a real time API based on web sockets.\nThe bot connects to Slack using the same protocol that the native Slack clients use!\n\nTo connect a bot to Slack, [get a Bot API token from the Slack integrations page](https://my.slack.com/services/new/bot).\n\nNote: Since API tokens can be used to connect to your team\'s Slack, it is best practices to handle API tokens with caution. For example, pass tokens in to your application via evironment variable or command line parameter rather than include it in the code itself.\nThis is particularly true if you store and use API tokens on behalf of users other than yourself!\n\n[Read Slack\'s Bot User documentation](https://api.slack.com/bot-users)\n\n#### controller.spawn()\n| Argument | Description\n|--- |---\n| config | Incoming message object\n\nSpawn an instance of your bot and connect it to Slack.\nThis function takes a configuration object which should contain\nat least one method of talking to the Slack API.\n\nTo use the real time / bot user API, pass in a token, preferably via\nan environment variable.\n\nControllers can also spawn bots that use [incoming webhooks](#incoming-webhooks).\n\n#### bot.startRTM()\n| Argument | Description\n|--- |---\n| callback | _Optional_ Callback in the form function(err,bot,payload) { ... }\n\nOpens a connection to Slack\'s real time API. This connection will remain\nopen until it fails or is closed using `closeRTM()`.\n\nThe optional callback function receives:\n\n* Any error that occurred while connecting to Slack\n* An updated bot object\n* The resulting JSON payload of the Slack API command [rtm.start](https://api.slack.com/methods/rtm.start)\n\nThe payload that this callback function receives contains a wealth of information\nabout the bot and its environment, including a complete list of the users\nand channels visible to the bot. This information should be cached and used\nwhen possible instead of calling Slack\'s API.\n\nA successful connection the API will also cause a `rtm_open` event to be\nfired on the `controller` object.\n\n\n#### bot.closeRTM()\n\nClose the connection to the RTM. Once closed, an `rtm_close` event is fired\non the `controller` object.\n\n\n```javascript\nvar Botkit = require(\'Botkit\');\n\nvar controller = Botkit.slackbot();\n\nvar bot = controller.spawn({\n  token: my_slack_bot_token\n})\n\nbot.startRTM(function(err,bot,payload) {\n  if (err) {\n    throw new Error(\'Could not connect to Slack\');\n  }\n});\n```\n\n### Responding to events\n\nOnce connected to Slack, bots receive a constant stream of events - everything from the normal messages you would expect to typing notifications and presence change events.\n\nBotkit\'s message parsing and event system does a great deal of filtering on this\nreal time stream so developers do not need to parse every message.  See [Receiving Messages](#receiving-messages)\nfor more information about listening for and responding to messages.\n\nIt is also possible to bind event handlers directly to any of the enormous number of native Slack events, as well as a handful of custom events emitted by Botkit.\n\nYou can receive and handle any of the [native events thrown by slack](https://api.slack.com/events).\n\n```javascript\ncontroller.on(\'channel_joined\',function(bot,message) {\n\n  // message contains data sent by slack\n  // in this case:\n  // https://api.slack.com/events/channel_joined\n\n});\n```\n\nYou can also receive and handle a long list of additional events caused\nby messages that contain a subtype field, [as listed here](https://api.slack.com/events/message)\n\n```javascript\ncontroller.on(\'channel_leave\',function(bot,message) {\n\n  // message format matches this:\n  // https://api.slack.com/events/message/channel_leave\n\n})\n```\n\nFinally, Botkit throws a handful of its own events!\nEvents related to the general operation of bots are below.\nWhen used in conjunction with the Slack Button, Botkit also fires\na [few additional events](#using-the-slack-button).\n\n#### Message/User Activity Events:\n\n| Event | Description\n|--- |---\n| message_received | a message was received by the bot\n| bot_channel_join | the bot has joined a channel\n| user_channel_join | a user has joined a channel\n| bot_group_join | the bot has joined a group\n| user_group_join | a user has joined a group\n| direct_message | the bot received a direct message from a user\n| direct_mention | the bot was addressed directly in a channel\n| mention | the bot was mentioned by someone in a message\n| ambient | the message received had no mention of the bot\n\n\n#### Websocket Events:\n\n| Event | Description\n|--- |---\n| rtm_open | a connection has been made to the RTM api\n| rtm_close | a connection to the RTM api has closed\n\n\n## Receiving Messages\n\nBotkit bots receive messages through a system of event handlers. Handlers can be set up to respond to specific types of messages,\nor to messages that match a given keyword or pattern.\n\nFor Slack, Botkit supports five type of message event:\n\n| Event | Description\n|--- |---\n| message_received  | This event is fired for any message of any kind that is received and can be used as a catch all\n| ambient | Ambient messages are messages that the bot can hear in a channel, but that do not mention the bot in any way\n| direct_mention| Direct mentions are messages that begin with the bot\'s name, as in "@bot hello"\n| mention | Mentions are messages that contain the bot\'s name, but not at the beginning, as in "hello @bot"\n| direct_message | Direct messages are sent via private 1:1 direct message channels\n\nThese message events can be handled using by attaching an event handler to the main controller object.\nThese event handlers take two parameters: the name of the event, and a callback function which is invoked whenever the event occurs.\nThe callback function receives a bot object, which can be used to respond to the message, and a message object.\n\n```javascript\n// reply to @bot hello\ncontroller.on(\'direct_mention\',function(bot,message) {\n\n  // reply to _message_ by using the _bot_ object\n  bot.reply(message,\'I heard you mention me!\');\n\n});\n\n// reply to a direct message\ncontroller.on(\'direct_message\',function(bot,message) {\n\n  // reply to _message_ by using the _bot_ object\n  bot.reply(message,\'You are talking directly to me\');\n\n});\n\n```\n\n### Matching Patterns and Keywords with `hears()`\n\nIn addition to these traditional event handlers, Botkit also provides the `hears()` function,\nwhich configures event handlers based on matching specific keywords or phrases in the message text.\nThe hears function works just like the other event handlers, but takes a third parameter which\nspecifies the keywords to match.\n\n| Argument | Description\n|--- |---\n| patterns | An _array_ or a _comma separated string_ containing a list of regular expressions to match\n| types  | An _array_ or a _comma separated string_ of the message events in which to look for the patterns\n| callback | callback function that receives a message object\n\n```javascript\ncontroller.hears([\'keyword\',\'^pattern$\'],[\'direct_message\',\'direct_mention\',\'mention\',\'ambient\'],function(bot,message) {\n\n  // do something to respond to message\n  // all of the fields available in a normal Slack message object are available\n  // https://api.slack.com/events/message\n  bot.reply(message,\'You used a keyword!\');\n\n});\n```\nFor example,\n\n```javascript\ncontroller.hears(\'open the (.*) doors\',[\'direct_message\',\'mention\'],function(bot,message) {\n  var doorType = message.match[1]; //match[1] is the (.*) group. match[0] is the entire group (open the (.*) doors).\n  if (doorType === \'pod bay\') {\n    return bot.reply(message, \'I\\\'m sorry, Dave. I\\\'m afraid I can\\\'t do that.\');\n  }\n  return bot.reply(message, \'Okay\');\n});\n```\n\n## Sending Messages\n\nBots have to send messages to deliver information and present an interface for their\nfunctionality.  Botkit bots can send messages in several different ways, depending\non the type and number of messages that will be sent.\n\nSingle message replies to incoming commands can be sent using the `bot.reply()` function.\n\nMulti-message replies, particulary those that present questions for the end user to respond to,\ncan be sent using the `bot.startConversation()` function and the related conversation sub-functions.\n\nBots can originate messages - that is, send a message based on some internal logic or external stimulus -\nusing `bot.say()` method.  Note that bots that do not need to respond to messages or hold conversations\nmay be better served by using Slack\'s [Incoming Webhooks](#incoming-webhooks) feature.\n\n### Single Message Replies to Incoming Messages\n\nOnce a bot has received a message using a `on()` or `hears()` event handler, a response\ncan be sent using `bot.reply()`.\n\nMessages sent using `bot.reply()` are sent immediately. If multiple messages are sent via\n`bot.reply()` in a single event handler, they will arrive in the Slack client very quickly\nand may be difficult for the user to process. We recommend using `bot.startConversation()`\nif more than one message needs to be sent.\n\nYou may pass either a string, or a message object to the function. Message objects may contain\nany of the fields supported by [Slack\'s chat.postMessage](https://api.slack.com/methods/chat.postMessage) API.\n\n#### bot.reply()\n\n| Argument | Description\n|--- |---\n| message | Incoming message object\n| reply | _String_ or _Object_ Outgoing response\n| callback | _Optional_ Callback in the form function(err,response) { ... }\n\n```javascript\ncontroller.hears([\'keyword\',\'^pattern$\'],[\'direct_message\',\'direct_mention\',\'mention\'],function(bot,message) {\n\n  // do something to respond to message\n  // ...\n\n  bot.reply(message,"Tell me more!");\n\n});\n\ncontroller.on(\'ambient\',function(bot,message) {\n\n    // do something...\n\n    // then respond with a message object\n    bot.reply(message,{\n      text: "A more complex response",\n      username: "ReplyBot",\n      icon_emoji: ":dash:",\n    });\n\n})\n\n//Using attachments\ncontroller.hears(\'another_keyword\',\'direct_message,direct_mention\',function(bot,message) {\n  var reply_with_attachments = {\n    \'username\': \'My bot\' ,\n    \'text\': \'This is a pre-text\',\n    \'attachments\': [\n      {\n        \'fallback\': \'To be useful, I need your to invite me in a channel.\',\n        \'title\': \'How can I help you?\',\n        \'text\': \'To be useful, I need your to invite me in a channel \',\n        \'color\': \'#7CD197\'\n      }\n    ],\n    \'icon_url\': \'http://lorempixel.com/48/48\'\n    }\n\n  bot.reply(message, reply_with_attachments);\n});\n\n```\n\n### Multi-message Replies to Incoming Messages\n\nFor more complex commands, multiple messages may be necessary to send a response,\nparticularly if the bot needs to collect additional information from the user.\n\nBotkit provides a `Conversation` object type that is used to string together several\nmessages, including questions for the user, into a cohesive unit. Botkit conversations\nprovide useful methods that enable developers to craft complex conversational\nuser interfaces that may span a several minutes of dialog with a user, without having to manage\nthe complexity of connecting multiple incoming and outgoing messages across\nmultiple API calls into a single function.\n\nMessages sent as part of a conversation are sent no faster than one message per second,\nwhich roughly simulates the time it would take for the bot to "type" the message.\n(It is possible to adjust this delay - see [special behaviors](#special-behaviors))\n\n### Start a Conversation\n\n#### bot.startConversation()\n| Argument | Description\n|---  |---\n| message   | incoming message to which the conversation is in response\n| callback  | a callback function in the form of  function(err,conversation) { ... }\n\n`startConversation()` is a function that creates conversation in response to an incoming message.\nThe conversation will occur _in the same channel_ in which the incoming message was received.\nOnly the user who sent the original incoming message will be able to respond to messages in the conversation.\n\n#### bot.startPrivateConversation()\n| Argument | Description\n|---  |---\n| message   | incoming message to which the conversation is in response\n| callback  | a callback function in the form of  function(err,conversation) { ... }\n\n`startPrivateConversation()` works juts like `startConversation()`, but the resulting\nconversation that is created will occur in a private direct message channel between\nthe user and the bot.\n\nIt is possible to initiate a private conversation by passing a message object, containing the user\'s Slack ID.\n\n```javascript\n//assume var user_id has been defined\nbot.startPrivateConversation({user: user_id}, function(response, convo){\n  convo.say(\'Hello, I am your bot.\')\n})\n```\n\n\n### Control Conversation Flow\n\n#### conversation.say()\n| Argument | Description\n|---  |---\n| message   | String or message object\n\nCall convo.say() several times in a row to queue messages inside the conversation. Only one message will be sent at a time, in the order they are queued.\n\n```javascript\ncontroller.hears([\'hello world\'],[\'direct_message\',\'direct_mention\',\'mention\',\'ambient\'],function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.say(\'Hello!\');\n    convo.say(\'Have a nice day!\');\n\n    //Using attachments\n    var message_with_attachments = {\n      \'username\': \'My bot\' ,\n      \'text\': \'this is a pre-text\',\n      \'attachments\': [\n        {\n          \'fallback\': \'To be useful, I need your to invite me in a channel.\',\n          \'title\': \'How can I help you?\',\n          \'text\': \' To be useful, I need your to invite me in a channel \',\n          \'color\': \'#7CD197\'\n        }\n      ],\n      \'icon_url\': \'http://lorempixel.com/48/48\'\n      }\n\n      convo.say(message_with_attachments);\n    });\n\n  })\n});\n```\n\n#### conversation.ask()\n| Argument | Description\n|---  |---\n| message   | String or message object containing the question\n| callback _or_ array of callbacks   | callback function in the form function(response_message,conversation), or array of objects in the form ``{ pattern: regular_expression, callback: function(response_message,conversation) { ... } }``\n| capture_options | _Optional_ Object defining options for capturing the response\n\nWhen passed a callback function, conversation.ask will execute the callback function for any response.\nThis allows the bot to respond to open ended questions, collect the responses, and handle them in whatever\nmanner it needs to.\n\nWhen passed an array, the bot will look first for a matching pattern, and execute only the callback whose\npattern is matched. This allows the bot to present multiple choice options, or to proceed\nonly when a valid response has been received. At least one of the patterns in the array must be marked as the default option,\nwhich will be called should no other option match. Botkit comes pre-built with several useful patterns which can be used with this function. See [included utterances](#included-utterances)\n\nCallback functions passed to `ask()` receive two parameters - the first is a standard message object containing\nthe user\'s response to the question. The second is a reference to the conversation itself.\n\nNote that in order to continue the conversation, `convo.next()` must be called by the callback function. This\nfunction tells Botkit to continue processing the conversation. If it is not called, the conversation will hang\nand never complete causing memory leaks and instability of your bot application!\n\nThe optional third parameter `capture_options` can be used to define different behaviors for collecting the user\'s response.\nThis object can contain the following fields:\n\n| Field | Description\n|--- |---\n| key | _String_ If set, the response will be stored and can be referenced using this key\n| multiple | _Boolean_ if true, support multi-line responses from the user (allow the user to respond several times and aggregate the response into a single multi-line value)\n\n##### Using conversation.ask with a callback:\n\n```javascript\ncontroller.hears([\'question me\'],[\'direct_message\',\'direct_mention\',\'mention\',\'ambient\'],function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.ask(\'How are you?\',function(response,convo) {\n\n      convo.say(\'Cool, you said: \' + response.text);\n      convo.next();\n\n    });\n\n  })\n\n});\n```\n\n##### Using conversation.ask with an array of callbacks:\n\n```javascript\ncontroller.hears([\'question me\'],[\'direct_message\',\'direct_mention\',\'mention\',\'ambient\'],function(bot,message) {\n\n  // start a conversation to handle this response.\n  bot.startConversation(message,function(err,convo) {\n\n    convo.ask(\'Shall we proceed Say YES, NO or DONE to quit.\',[\n      {\n        pattern: \'done\',\n        callback: function(response,convo) {\n          convo.say(\'OK you are done!\');\n          convo.next();\n        }\n      },\n      {\n        pattern: bot.utterances.yes,\n        callback: function(response,convo) {\n          convo.say(\'Great! I will continue...\');\n          // do something else...\n          convo.next();\n\n        }\n      },\n      {\n        pattern: bot.utterances.no,\n        callback: function(response,convo) {\n          convo.say(\'Perhaps later.\');\n          // do something else...\n          convo.next();\n        }\n      },\n      {\n        default: true,\n        callback: function(response,convo) {\n          // just repeat the question\n          convo.repeat();\n          convo.next();\n        }\n      }\n    ]);\n\n  })\n\n});\n```\n\n##### Multi-stage conversations\n\n![multi-stage convo example](https://www.evernote.com/shard/s321/sh/7243cadf-be40-49cf-bfa2-b0f524176a65/f9257e2ff5ee6869/res/bc778282-64a5-429c-9f45-ea318c729225/screenshot.png?resizeSmall&width=832)\n\nThe recommended way to have multi-stage conversations is with multiple functions\nwhich call eachother. Each function asks just one question. Example:\n\n```javascript\ncontroller.hears([\'pizzatime\'],[\'ambient\'],function(bot,message) {\n  bot.startConversation(message, askFlavor);\n});\n\naskFlavor = function(response, convo) {\n  convo.ask(\'What flavor of pizza do you want?\', function(response, convo) {\n    convo.say(\'Awesome.\');\n    askSize(response, convo);\n    convo.next();\n  });\n}\naskSize = function(response, convo) {\n  convo.ask(\'What size do you want?\', function(response, convo) {\n    convo.say(\'Ok.\')\n    askWhereDeliver(response, convo);\n    convo.next();\n  });\n}\naskWhereDeliver = function(response, convo) {\n  convo.ask(\'So where do you want it delivered?\', function(response, convo) {\n    convo.say(\'Ok! Good by.\');\n    convo.next();\n  });\n}\n```\n\nThe full code for this example can be found in ```examples/convo_bot.js```.\n\n##### Included Utterances\n\n| Pattern Name | Description\n|--- |---\n| bot.utterances.yes | Matches phrases like yes, yeah, yup, ok and sure.\n| bot.utterances.no | Matches phrases like no, nah, nope\n\n##### Conversation Control Functions\n\nIn order to direct the flow of the conversation, several helper functions\nare provided.  These functions should only be called from within a convo.ask\nhandler function!\n\n`convo.sayFirst(message)` Works just like convo.say, but injects a message into the first spot in the queue\nso that it is sent immediately, before any other queued messages.\n\n`convo.stop()` end the conversation immediately, and set convo.status to `stopped`\n\n`convo.repeat()` repeat the last question sent and continue to wait for a response.\n\n`convo.silentRepeat()` simply wait for another response without saying anything.\n\n`convo.next()` proceed to the next message in the conversation.  *This must be called* at the end of each handler.\n\n### Handling End of Conversation\n\nConversations trigger events during the course of their life.  Currently,\nonly two events are fired, and only one is very useful: end.\n\nConversations end naturally when the last message has been sent and no messages remain in the queue.\nIn this case, the value of `convo.status` will be `completed`. Other values for this field include `active`, `stopped`, and\n`timeout`.\n\n```javascript\nconvo.on(\'end\',function(convo) {\n\n  if (convo.status==\'completed\') {\n    // do something useful with the users responses\n    var res = convo.extractResponses();\n\n    // reference a specific response by key\n    var value  = convo.extractResponse(\'key\');\n\n    // ... do more stuff...\n\n  } else {\n    // something happened that caused the conversation to stop prematurely\n  }\n\n});\n```\n\n#### convo.extractResponses()\n\nReturns an object containing all of the responses a user sent during the course of a conversation.\n\n```javascript\nvar values = convo.extractResponses();\nvar value = values.key;\n```\n\n#### convo.extractResponse()\n\nReturn one specific user response, identified by its key.\n\n```javascript\nvar value  = convo.extractResponse(\'key\');\n```\n\n### Originating Messages\n\n#### bot.say()\n| Argument | Description\n|--- |---\n| message | A message object\n| callback | _Optional_ Callback in the form function(err,response) { ... }\n\nNote: If your primary need is to spontaneously send messages rather than\nrespond to incoming messages, you may want to use [Slack\'s incoming webhooks feature](#incoming-webhooks) rather than the real time API.\n\n```javascript\nbot.say(\n  {\n    text: \'my message text\',\n    channel: \'C0H338YH4\'\n  }\n);\n```\n\n## Working with Slack Integrations\n\nThere are a dizzying number of ways to integrate your application into Slack.\nUp to this point, this document has mainly dealt with the real time / bot user\nintegration.  In addition to this type of integration, Botkit also supports:\n\n* Incoming Webhooks - a way to send (but not receive) messages to Slack\n* Outgoing Webhooks - a way to receive messages from Slack based on a keyword or phrase\n* Slash Command - a way to add /slash commands to Slack\n* Slack Web API - a full set of RESTful API tools to deal with Slack\n* The Slack Button - a way to build Slack applications that can be used by multiple teams\n\n\n```javascript\nvar Botkit = require(\'botkit\');\nvar controller = Botkit.slackbot({})\n\nvar bot = controller.spawn({\n  token: my_slack_bot_token\n});\n\n// use RTM\nbot.startRTM(function(err,bot,payload) {\n  // handle errors...\n});\n\n// send webhooks\nbot.configureIncomingWebhook({url: webhook_url});\nbot.sendWebhook({\n  text: \'Hey!\',\n  channel: \'#testing\',\n},function(err,res) {\n  // handle error\n});\n\n// receive outgoing or slash commands\n// if you are already using Express, you can use your own server instance...\ncontroller.setupWebserver(process.env.port,function(err,webserver) {\n\n  controller.createWebhookEndpoints(controller.webserver);\n\n});\n\ncontroller.on(\'slash_command\',function(bot,message) {\n\n  // reply to slash command\n  bot.replyPublic(message,\'Everyone can see the results of this slash command\');\n\n});\n```\n\n\n\n### Incoming webhooks\n\nIncoming webhooks allow you to send data from your application into Slack.\nTo configure Botkit to send an incoming webhook, first set one up\nvia [Slack\'s integration page](https://my.slack.com/services/new/incoming-webhook/).\n\nOnce configured, use the `sendWebhook` function to send messages to Slack.\n\n[Read official docs](https://api.slack.com/incoming-webhooks)\n\n#### bot.configureIncomingWebhook()\n| Argument | Description\n|--- |---\n| config | Configure a bot to send webhooks\n\nAdd a webhook configuration to an already spawned bot.\nIt is preferable to spawn the bot pre-configured, but hey, sometimes\nyou need to do it later.\n\n#### bot.sendWebhook()\n| Argument | Description\n|--- |---\n| message | A message object\n| callback | _Optional_ Callback in the form function(err,response) { ... }\n\nPass `sendWebhook` an object that contains at least a `text` field.\n This object may also contain other fields defined [by Slack](https://api.slack.com/incoming-webhooks) which can alter the\n appearance of your message.\n\n```javascript\nvar bot = controller.spawn({\n  incoming_webhook: {\n    url: <my_webhook_url>\n  }\n})\n\nbot.sendWebhook({\n  text: \'This is an incoming webhook\',\n  channel: \'#general\',\n},function(err,res) {\n  if (err) {\n    // ...\n  }\n});\n```\n\n\n### Outgoing Webhooks and Slash commands\n\nOutgoing webhooks and Slash commands allow you to send data out of Slack.\n\nOutgoing webhooks are used to match keywords or phrases in Slack. [Read Slack\'s official documentation here.](https://api.slack.com/outgoing-webhooks)\n\nSlash commands are special commands triggered by typing a "/" then a command.\n[Read Slack\'s official documentation here.](https://api.slack.com/slash-commands)\n\nThough these integrations are subtly different, Botkit normalizes the details\nso developers may focus on providing useful functionality rather than peculiarities\nof the Slack API parameter names.\n\nNote that since these integrations use send webhooks from Slack to your application,\nyour application will have to be hosted at a public IP address or domain name,\nand properly configured within Slack.\n\n[Set up an outgoing webhook](https://xoxco.slack.com/services/new/outgoing-webhook)\n\n[Set up a Slash command](https://xoxco.slack.com/services/new/slash-commands)\n\n```javascript\ncontroller.setupWebserver(port,function(err,express_webserver) {\n  controller.createWebhookEndpoints(express_webserver)\n});\n\ncontroller.on(\'slash_command\',function(bot,message) {\n\n    // reply to slash command\n    bot.replyPublic(message,\'Everyone can see this part of the slash command\');\n    bot.replyPrivate(message,\'Only the person who used the slash command can see this.\');\n\n})\n\ncontroller.on(\'outgoing_webhook\',function(bot,message) {\n\n    // reply to outgoing webhook command\n    bot.replyPublic(message,\'Everyone can see the results of this webhook command\');\n\n})\n```\n\n#### controller.setupWebserver()\n| Argument | Description\n|---  |---\n| port | port for webserver\n| callback | callback function\n\nSetup an [Express webserver](http://expressjs.com/en/index.html) for\nuse with `createwWebhookEndpoints()`\n\nIf you need more than a simple webserver to receive webhooks,\nyou should by all means create your own Express webserver!\n\nThe callback function receives the Express object as a parameter,\nwhich may be used to add further web server routes.\n\n#### controller.createWebhookEndpoints()\n\nThis function configures the route `http://_your_server_/slack/receive`\nto receive webhooks from Slack.\n\nThis url should be used when configuring Slack.\n\nWhen a slash command is received from Slack, Botkit fires the `slash_command` event.\n\nWhen an outgoing webhook is recieved from Slack, Botkit fires the `outgoing_webhook` event.\n\n\n#### bot.replyPublic()\n| Argument | Description\n|---  |---\n| src | source message as received from slash or webhook\n| reply | reply message (string or object)\n| callback | optional callback\n\nWhen used with outgoing webhooks, this function sends an immediate response that is visible to everyone in the channel.\n\nWhen used with slash commands, this function has the same functionality. However,\nslash commands also support private, and delayed messages. See below.\n[View Slack\'s docs here](https://api.slack.com/slash-commands)\n\n#### bot.replyPrivate()\n\n| Argument | Description\n|---  |---\n| src | source message as received from slash\n| reply | reply message (string or object)\n| callback | optional callback\n\n\n#### bot.replyPublicDelayed()\n\n| Argument | Description\n|---  |---\n| src | source message as received from slash\n| reply | reply message (string or object)\n| callback | optional callback\n\n#### bot.replyPrivateDelayed()\n\n| Argument | Description\n|---  |---\n| src | source message as received from slash\n| reply | reply message (string or object)\n| callback | optional callback\n\n\n\n### Using the Slack Web API\n\nAll (or nearly all - they change constantly!) of Slack\'s current web api methods are supported\nusing a syntax designed to match the endpoints themselves.\n\nIf your bot has the appropriate scope, it may call [any of these method](https://api.slack.com/methods) using this syntax:\n\n```javascript\nbot.api.channels.list({},function(err,response) {\n  //Do something...\n})\n```\n\n\n# Advanced Topics\n\n\n## Storing Information\n\nBotkit has a built in storage system used to keep data on behalf of users and teams between sessions. Botkit uses this system automatically when storing information for Slack Button applications (see below).\n\nBy default, Botkit will use [json-file-store](https://github.com/flosse/json-file-store) to keep data in JSON files in the filesystem of the computer where the bot is executed. (Note this will not work on Heroku or other hosting systems that do not let node applications write to the file system.) Initialize this system when you create the bot:\n```javascript\nvar controller = Botkit.slackbot({\n  json_file_store: \'path_to_json_database\'\n});\n```\n\nThis system supports freeform storage on a team-by-team, user-by-user, and channel-by-channel basis. Basically ```controller.storage``` is a key value store. All access to this system is through the following nine functions. Example usage:\n```javascript\ncontroller.storage.users.save({id: message.user, foo:\'bar\'}, function(err) { ... });\ncontroller.storage.users.get(id, function(err, user_data) {...});\ncontroller.storage.users.all(function(err, all_user_data) {...});\n\ncontroller.storage.channels.save({id: message.channel, foo:\'bar\'}, function(err) { ... });\ncontroller.storage.channels.get(id, function(err, channel_data) {...});\ncontroller.storage.channels.all(function(err, all_channel_data) {...});\n\ncontroller.storage.teams.save({id: message.team, foo:\'bar\'}, function(err) { ... });\ncontroller.storage.teams.get(id, function(err, team_data) {...});\ncontroller.storage.teams.all(function(err, all_team_data) {...});\n```\n\nNote that save must be passed an object with an id. It is recommended to use the team/user/channel id for this purpose.\n```[user/channel/team]_data``` will always be an object while ```all_[user/channel/team]_data``` will always be a list of objects.\n\n### Writing your own storage module\n\nIf you want to use a database or do something else with your data,\nyou can write your own storage module and pass it in.\n\nMake sure your module returns an object with all the methods. See [simple_storage.js](https://github.com/howdyai/botkit/blob/master/lib/storage/simple_storage.js) for an example of how it is done!\nMake sure your module passes the test in [storage_test.js](https://github.com/howdyai/botkit/blob/master/lib/storage/storage_test.js).\n\nThen, use it when you create your bot:\n```javascript\nvar controller = Botkit.slackbot({\n  storage: my_storage_provider\n})\n```\n\n### Writing your own logging module\n\nBy default, your bot will log to the standard JavaScript `console` object\navailable in Node.js. This will synchronously print logging messages to stdout\nof the running process.\n\nThere may be some cases, such as remote debugging or rotating of large logs,\nwhere you may want a more sophisticated logging solution. You can write your\nown logging module that uses a third-party tool, like\n[winston](https://github.com/winstonjs/winston) or\n[Bristol](https://github.com/TomFrost/Bristol). Just create an object with a\n`log` method. That method should take a severity level (such as `\'error\'` or\n`\'debug\'`) as its first argument, and then any number of other arguments that\nwill be logged as messages. (Both Winston and Bristol create objects of this\ndescription; it\'s a common interface.)\n\nThen, use it when you create your bot:\n```javascript\nvar controller = Botkit.slackbot({\n  logger: new winston.Logger({\n    transports: [\n      new (winston.transports.Console)(),\n      new (winston.transports.File)({ filename: \'./bot.log\' })\n    ]\n  })\n});\n```\n\n## Use the Slack Button\n\nThe [Slack Button](https://api.slack.com/docs/slack-button) is a way to offer a Slack\nintegration as a service available to multiple teams. Botkit includes a framework\non top of which Slack Button applications can be built.\n\nSlack button applications can use one or more of the [real time API](),\n[incoming webhook]() and [slash command]() integrations, which can be\nadded *automatically* to a team using a special oauth scope.\n\nIf special oauth scopes sounds scary, this is probably not for you!\nThe Slack Button is useful for developers who want to offer a service\nto multiple teams.\n\nHow many teams can a Slack button app built using Botkit handle?\nThis will largely be dependent on the environment it is hosted in and the\ntype of integrations used.  A reasonably well equipped host server should\nbe able to easily handle _at least one hundred_ real time connections at once.\n\nTo handle more than one hundred bots at once, [consider speaking to the\ncreators of Botkit at Howdy.ai](http://howdy.ai)\n\nFor Slack button applications, Botkit provides:\n\n* A simple webserver\n* OAuth Endpoints for login via Slack\n* Storage of API tokens and team data via built-in Storage\n* Events for when a team joins, a new integration is added, and others...\n\nSee the [included examples](#included-examples) for several ready to use example apps.\n\n#### controller.configureSlackApp()\n\n| Argument | Description\n|---  |---\n| config | configuration object containing clientId, clientSecret, redirectUri and scopes\n\nConfigure Botkit to work with a Slack application.\n\nGet a clientId and clientSecret from [Slack\'s API site](https://api.slack.com/applications).\nConfigure Slash command, incoming webhook, or bot user integrations on this site as well.\n\nConfiguration must include:\n\n* clientId - Application clientId from Slack\n* clientSecret - Application clientSecret from Slack\n* redirectUri - the base url of your application\n* scopes - an array of oauth permission scopes\n\nSlack has [_many, many_ oauth scopes](https://api.slack.com/docs/oauth-scopes)\nthat can be combined in different ways. There are also [_special oauth scopes_\nused when requesting Slack Button integrations](https://api.slack.com/docs/slack-button).\nIt is important to understand which scopes your application will need to function,\nas without the proper permission, your API calls will fail.\n\n#### controller.createOauthEndpoints()\n| Argument | Description\n|---  |---\n| webserver | an Express webserver Object\n| error_callback | function to handle errors that may occur during oauth\n\nCall this function to create two web urls that handle login via Slack.\nOnce called, the resulting webserver will have two new routes: `http://_your_server_/login` and `http://_your_server_/oauth`. The second url will be used when configuring\nthe "Redirect URI" field of your application on Slack\'s API site.\n\n\n```javascript\nvar Botkit = require(\'botkit\');\nvar controller = Botkit.slackbot();\n\ncontroller.configureSlackApp({\n  clientId: process.env.clientId,\n  clientSecret: process.env.clientSecret,\n  redirectUri: \'http://localhost:3002\',\n  scopes: [\'incoming-webhook\',\'team:read\',\'users:read\',\'channels:read\',\'im:read\',\'im:write\',\'groups:read\',\'emoji:read\',\'chat:write:bot\']\n});\n\ncontroller.setupWebserver(process.env.port,function(err,webserver) {\n\n  // set up web endpoints for oauth, receiving webhooks, etc.\n  controller\n    .createHomepageEndpoint(controller.webserver)\n    .createOauthEndpoints(controller.webserver,function(err,req,res) { ... })\n    .createWebhookEndpoints(controller.webserver);\n\n});\n\n```\n\n### How to identify what team your message came from\n```javascript\nbot.identifyTeam(function(err,team_id) {\n\n})\n```\n\n\n### How to identify the bot itself (for RTM only)\n```javascript\nbot.identifyBot(function(err,identity) {\n  // identity contains...\n  // {name, id, team_id}\n})\n```\n\n\n### Slack Button specific events:\n\n| Event | Description\n|--- |---\n| create_incoming_webhook |\n| create_bot |\n| update_team |\n| create_team |\n| create_user |\n| update_user |\n| oauth_error |\n\n# Chat with us at dev4slack.slack.com\nYou can get an invite here: http://dev4slack.xoxco.com/.\n',
116 silly publish   readmeFilename: 'readme.md',
116 silly publish   _id: 'botkit@0.0.7',
116 silly publish   dist: { shasum: 'c5d832bee3187baca6601180849b6db14a45041e' },
116 silly publish   _from: '.' }
117 error need auth auth and email required for publishing
117 error need auth You need to authorize this machine using `npm adduser`
118 error System Darwin 15.0.0
119 error command "/usr/local/bin/node" "/usr/local/bin/npm" "publish"
120 error cwd /Users/ben/sites/botkit
121 error node -v v0.10.21
122 error npm -v 1.3.11
123 error code ENEEDAUTH
124 verbose exit [ 1, true ]
